# 一、数组 ⭐

## 1、多数元素

>#169：https://leetcode-cn.com/problems/majority-element/	剑指offer39	HOT100    牛客TOP101
>
>算法思想：摩尔投票法 / 同归于尽法：数组中只要两个元素不相等，则两者同归于尽，最后剩下的一定是众数。

```
exmaple:   [1, 2, 3, 2, 2, 2, 5, 4, 2]
candidate:  1  1
cnt:		1  0 (1 和 2 同归于尽，1 的 cnt--)

exmaple:   [1, 2, 3, 2, 2, 2, 5, 4, 2]
candidate:  1  1  3  3  2  2  2  2  2 (最终答案)
cnt:		1  0  1  0  1  2  1  0  1
```

>- 时间复杂度：O(n)
>- 空间复杂度：O(1)

```java
public int majorityElement(int[] nums) {
    if (nums.length == 1) return nums[0];
    int candidate = nums[0];
    int cnt = 1;
    for (int i = 1; i < nums.length; i++) {
        int num = nums[i];
        if (cnt == 0) {
            candidate = num;
            cnt = 1;
            continue;
        }
        if (num == candidate)
            cnt++;
        else
            cnt--;
    }
    return candidate;
}
```

## 2、下一个排列

> \#31：https://leetcode-cn.com/problems/next-permutation/	HOT100

**2.1、暴力法**

> 求出全排列，再升序排序，找到当前排列的下一个排列。
>
> - 时间复杂度：O(n!)
> - 空间复杂度：O(n)

**2.2、一遍扫描**

> 如：nums = [6, 9, 1, 4, 8, 7, 5, 3]，下一个排列应该是 [6, 9, 1, 5, 3, 4, 7, 8]
>
> 算法思想：
>
> 1. 从后往前遍历数组 nums[]，找到第一个**升序对** <nums[i], nums[i+1]> (即 <4, 8>)，则 nums[i+1 ... end] 一定是**降序**的！
> 2. 在末尾的降序子序列中 (即 8, 7, 5, 3) 查找只比 nums[i] (即 4) **大**一丢丢的数 num[j] (即 5)，swap(nums[i], nums[j])；(此时 nums=[6, 9, 1, 5, 8, 7, 4, 3])
> 3. 将末尾降序子序列按升序排序。(此时 nums=[6, 9, 1, 5, 3, 4, 7, 8])
>
> - 时间复杂度：O(n)
> - 空间复杂度：O(1)

```java
public void nextPermutation(int[] nums) {
    int len = nums.length;
    int i = len - 2;
    // 1.从后向前找到第一个升序对的头元素 nums[i]
    while (i >= 0 && nums[i] >= nums[i + 1]) i--;
    // 2.若没找到，即特殊情况：nums[] 整体降序，只需将其排为升序返回即可
    if (i < 0) {
        // Arrays.sort(nums);
        reverse(nums, 0, len);    // O(n)
        return;
    }
    // 3.找到后，在末尾的降序子序列中查找比 nums[i] 大一丢丢的数 nums[j]，swap(nums[i], nums[j])
    int j = len - 1;
    while (j > i && nums[i] >= nums[j]) j--;      // 此处从后向前找，也可从前向后找
    swap(nums, i, j);
    // 4.末尾降序子序列升序排序
    // Arrays.sort(nums, i+1, len);
    reverse(nums, i + 1, len);     // O(n)
}

private void reverse(int[] nums, int start, int end) {
    for (int i = start, j = end - 1; i < j; i++, j--) {
        swap(nums, i, j);
    }
}

private void swap(int[] nums, int i, int j) {
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}
```

> 进阶：求上一个排列
>
> 如：nums = [6, 9, 1, 5, 3, 4, 7, 8]，上一个排列应该是 [6, 9, 1, 4, 8, 7, 5, 3]。
>
> 算法思想：
>
> 1. 从后往前遍历数组 nums[]，找到第一个**逆序对** <nums[i], nums[i+1]> (即 <5, 3>)，则 nums[i+1 ... end] 一定是**升序**的！
> 2. 在末尾的升序子序列中 (即 3, 4, 7, 8) 查找只比 nums[i] (即 5) **小**一丢丢的数 num[j] (即 4)，swap(nums[i], nums[j])；(此时 nums=[6, 9, 1, 4, 3, 5, 7, 8])
> 3. 将末尾升序子序列按降序排序。(此时 nums=[6, 9, 1, 4, 8, 7, 5, 3])
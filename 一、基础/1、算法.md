# 一、数组 ⭐

## 1、多数元素

>#169：https://leetcode-cn.com/problems/majority-element/	剑指offer39	HOT100    牛客TOP101
>
>算法思想：摩尔投票法 / 同归于尽法：数组中只要两个元素不相等，则两者同归于尽，最后剩下的一定是众数。

```
exmaple:   [1, 2, 3, 2, 2, 2, 5, 4, 2]
candidate:  1  1
cnt:		1  0 (1 和 2 同归于尽，1 的 cnt--)

exmaple:   [1, 2, 3, 2, 2, 2, 5, 4, 2]
candidate:  1  1  3  3  2  2  2  2  2 (最终答案)
cnt:		1  0  1  0  1  2  1  0  1
```

>- 时间复杂度：O(n)
>- 空间复杂度：O(1)

```java
public int majorityElement(int[] nums) {
    if (nums.length == 1) return nums[0];
    int candidate = nums[0];
    int cnt = 1;
    for (int i = 1; i < nums.length; i++) {
        int num = nums[i];
        if (cnt == 0) {
            candidate = num;
            cnt = 1;
            continue;
        }
        if (num == candidate)
            cnt++;
        else
            cnt--;
    }
    return candidate;
}
```

## 2、下一个排列

> \#31：https://leetcode-cn.com/problems/next-permutation/	HOT100

**2.1、暴力法**

> 求出全排列，再升序排序，找到当前排列的下一个排列。
>
> - 时间复杂度：O(n!)
> - 空间复杂度：O(n)

**2.2、一遍扫描**

> 如：nums = [6, 9, 1, 4, 8, 7, 5, 3]，下一个排列应该是 [6, 9, 1, 5, 3, 4, 7, 8]
>
> 算法思想：
>
> 1. 从后往前遍历数组 nums[]，找到第一个**升序对** <nums[i], nums[i+1]> (即 <4, 8>)，则 nums[i+1 ... end] 一定是**降序**的！
> 2. 在末尾的降序子序列中 (即 8, 7, 5, 3) 查找只比 nums[i] (即 4) **大**一丢丢的数 num[j] (即 5)，swap(nums[i], nums[j])；(此时 nums=[6, 9, 1, 5, 8, 7, 4, 3])
> 3. 将末尾降序子序列按升序排序。(此时 nums=[6, 9, 1, 5, 3, 4, 7, 8])
>
> - 时间复杂度：O(n)
> - 空间复杂度：O(1)

```java
public void nextPermutation(int[] nums) {
    int len = nums.length;
    int i = len - 2;
    // 1.从后向前找到第一个升序对的头元素 nums[i]
    while (i >= 0 && nums[i] >= nums[i + 1]) i--;
    // 2.若没找到，即特殊情况：nums[] 整体降序，只需将其排为升序返回即可
    if (i < 0) {
        // Arrays.sort(nums);
        reverse(nums, 0, len);    // O(n)
        return;
    }
    // 3.找到后，在末尾的降序子序列中查找比 nums[i] 大一丢丢的数 nums[j]，swap(nums[i], nums[j])
    int j = len - 1;
    while (j > i && nums[i] >= nums[j]) j--;      // 此处从后向前找，也可从前向后找
    swap(nums, i, j);
    // 4.末尾降序子序列升序排序
    // Arrays.sort(nums, i+1, len);
    reverse(nums, i + 1, len);     // O(n)
}

private void reverse(int[] nums, int start, int end) {
    for (int i = start, j = end - 1; i < j; i++, j--) {
        swap(nums, i, j);
    }
}

private void swap(int[] nums, int i, int j) {
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}
```

> 进阶：求上一个排列
>
> 如：nums = [6, 9, 1, 5, 3, 4, 7, 8]，上一个排列应该是 [6, 9, 1, 4, 8, 7, 5, 3]。
>
> 算法思想：
>
> 1. 从后往前遍历数组 nums[]，找到第一个**逆序对** <nums[i], nums[i+1]> (即 <5, 3>)，则 nums[i+1 ... end] 一定是**升序**的！
> 2. 在末尾的升序子序列中 (即 3, 4, 7, 8) 查找只比 nums[i] (即 5) **小**一丢丢的数 num[j] (即 4)，swap(nums[i], nums[j])；(此时 nums=[6, 9, 1, 4, 3, 5, 7, 8])
> 3. 将末尾升序子序列按降序排序。(此时 nums=[6, 9, 1, 4, 8, 7, 5, 3])
## 3、螺旋矩阵

> #54：https://leetcode-cn.com/problems/spiral-matrix/	剑指offer29	牛客HOT101	面试常考！
>
> - 时间复杂度：O(n<sup>2</sup>)
> - 空间复杂度：O(1)

```java
public List<Integer> spiralOrder(int[][] matrix) {
    List<Integer> list = new ArrayList<>();
    int top = 0, bottom = matrix.length - 1, left = 0, right = matrix[0].length - 1;
    while (top <= bottom && left <= right) {
        for (int i = left; i <= right; i++) list.add(matrix[top][i]);
        top++;
        for (int i = top; i <= bottom; i++) list.add(matrix[i][right]);
        right--;
        // top <= bottom 防止最后一次遍历后再走回头路，见输入示例2
        for (int i = right; i >= left && top <= bottom; i--) list.add(matrix[bottom][i]);
        bottom--;
        for (int i = bottom; i >= top && left <= right; i--) list.add(matrix[i][left]);
        left++;
    }
    return list;
}
```

## 4、把数组排成最小的数

> #剑指offer45：https:/paietcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/	#179 排成最大的数
>
> 算法思想：本题就是比较字符串 a + b 和 b + a 的大小问题

```java
public String minNumber(int[] nums) {
    List<String> list = new LinkedList<>();
    for (int num : nums) {
        list.add(String.valueOf(num));
    }
    list.sort(((o1, o2) -> (o1 + o2).compareTo(o2 + o1)));
    return String.join("", list);
}
```

> 自定义排序：

```java
public String minNumber(int[] nums) {
    String[] strs = new String[nums.length];
    for (int i = 0; i < strs.length; i++) {
        strs[i] = String.valueOf(nums[i]);
    }
    quickSort(strs, 0, strs.length - 1);
    StringBuilder sb = new StringBuilder();
    for (String str : strs) {
        sb.append(str);
    }
    return sb.toString();
}

private void quickSort(String[] strs, int left, int right) {
    if (left >= right) return;
    // 元素 p 被放到其最终位置，p 左边的都是比 p 小的，p 右边的都是比 p 大的，所以对其左右分别递归
    int p = randomPartition(strs, left, right);
    quickSort(strs, left, p - 1);
    quickSort(strs, p + 1, right);
}

private int randomPartition(String[] strs, int left, int right) {
    int randomIndex = left + new Random().nextInt(right - left + 1);    // 生成随机数 ∈[left, right]
    swap(strs, left, randomIndex);
    return partition(strs, left, right);
}

private int partition(String[] strs, int left, int right) {
    String temp = strs[left];
    while (left < right) {
        // 从右到左找第一个比自己小的
        while (left < right && (strs[right] + temp).compareTo(temp + strs[right]) >= 0) right--;
        strs[left] = strs[right];
        // 从左到右找第一个比自己大的
        while (left < right && (strs[left] + temp).compareTo(temp + strs[left]) <= 0) left++;
        strs[right] = strs[left];
    }
    strs[left] = temp;    // left == right 时循环结束，将元素 p 放到其最终位置
    return left;
}

private void swap(String[] strs, int i, int j) {
    String temp = strs[i];
    strs[i] = strs[j];
    strs[j] = temp;
}
```

 ## 5、构建乘积数组

> #238：https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/	HOT100	剑指offer66
>
> - 时间复杂度：O(n)
> - 空间复杂度：O(1)

```java
public int[] constructArr(int[] a) {
    int len = a.length;
    int product = 1;
    int[] leftArr = new int[len];			  // leftArr 保存 a[i] 左边的数的积 (不包括 i 自己)
    for (int i = 0; i < leftArr.length; i++) {
        leftArr[i] = product;
        product *= a[i];
    }
    product = 1;
    int[] rightArr = new int[len];		 	  // rightArr 保存 a[i] 右边的数的积 (不包括 i 自己)
    for (int i = rightArr.length - 1; i >= 0; i--) {
        rightArr[i] = product;
        product *= a[i];
    }
    int[] arr = new int[len];
    for (int i = 0; i < arr.length; i++) {
        arr[i] = leftArr[i] * rightArr[i];
    }
    return arr;
}
```

## 
